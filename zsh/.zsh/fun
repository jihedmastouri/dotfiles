#!/bin/zsh

function getTheme () {
	# use previous value if possible
	if [[ -f ~/.terminal_theme ]]; then
		theme=$(cat ~/.terminal_theme)
		[[ $theme == "0" ]] && echo "light" || echo "dark"
		return
	fi

	# -- Read from system --

	OS=$(uname -s)

	# Linux + Gnome
	if [[ "$OS" == "Linux" && "$DESKTOP_SESSION" == "gnome" ]]; then
		theme=$(gsettings get org.gnome.desktop.interface color-scheme)
		[[ "$theme" != "'prefer-dark'" ]] && echo "light" || echo "dark"
		return
	fi

	# -- default --
	echo "dark"
}

function goingDark () {
	echo "1" > ~/.terminal_theme
	export BAT_THEME="Dracula"
	export DELTA_FEATURE="dark-mode"
	export DARK_THEME="1"

    # Apply to system
    if [[ -n "$1" ]]; then
	    OS=$(uname -s)
        if [[ $OS == "Linux" ]]; then
            [[ $DESKTOP_SESSION == "gnome" ]] && gsettings set org.gnome.desktop.interface color-scheme prefer-dark
            # kde
        else
            # Darwin
        fi
    fi
}

function letThereBeLight () {
	echo "0" > ~/.terminal_theme
	export BAT_THEME="GitHub"
	export DELTA_FEATURE="light-mode"
	export DARK_THEME="0"

    # Apply to system
    if [[ -n "$1" ]]; then
	    OS=$(uname -s)
        if [[ $OS == "Linux" ]]; then
            [[ $DESKTOP_SESSION == "gnome" ]] && gsettings set org.gnome.desktop.interface color-scheme default
            # kde
        else
            # Darwin
        fi
    fi
}

function switchTheme () {
	[[ "$DARK_THEME" == "1" ]] && letThereBeLight foo || goingDark bar
}

function getBranch () {
  git_branch_icon='î‚ '
  git_branch=$(git rev-parse --abbrev-ref HEAD 2>/dev/null)
  [[ -n "$git_branch" ]] && echo "$git_branch_icon $git_branch"
}

function startd () {
    sudo systemctl start $1
    sudo systemctl enable $1
    sudo systemctl status $1 | grep "Active" | awk '{printf " Status: %s\n", $2}'
}

function bla () {
	echo "hi"
}

function Home () {
    [[ $# -eq 0 ]] && session="Home" || session=$1
    tmux attach-session -t "$session" &> /dev/null || tmux new -s "$session"
}

function myip () {
    curl -s 'https://ipinfo.io' | jq -r '.[]' | head --lines=1
}

function _myip () {
    ip address | grep -o "inet 192.*" | awk '{ print $2 }' | tr / ' ' | xargs
}

function gcm () {
    text=`curl -s curl -s https://whatthecommit.com/ | xmllint --html --xpath '//*[@id="content"]/p[1]/text()' -`
    git add -A && git commit -m "$text"
}

function myConda () {
    __conda_setup="$('/home/mj/anaconda3/bin/conda' 'shell.zsh' 'hook' 2> /dev/null)"
    if [ $? -eq 0 ]; then
        eval "$__conda_setup"
    else
        if [ -f "/home/mj/anaconda3/etc/profile.d/conda.sh" ]; then
            . "/home/mj/anaconda3/etc/profile.d/conda.sh"
        else
            export PATH="/home/mj/anaconda3/bin:$PATH"
        fi
    fi
    unset __conda_setup
}

function mcd () {
    mkdir -p $1 && cd $1
}

function fcd () {
  local result pstatus

  result="$(fuzzy-search -d "$@" | tee /dev/tty)"
  pstatus=${pipestatus[1]}  # exit status of fuzzy-search (not tee)

  # If fuzzy-search failed/cancelled
  if (( pstatus != 0 )); then
    echo "No dir was selected"
    return $pstatus
  fi

  # Only cd if it looks like a real directory
  if [[ -n "$result" && -d "$result" ]]; then
    cd "$result" || { echo "Failed to cd into: $result"; return 1; }
  else
    echo "No dir was selected"
    return 1
  fi
}

function fvim () {
  local result pstatus

  result="$(fuzzy-search -d "$@" | tee /dev/tty)"
  pstatus=${pipestatus[1]}  # exit status of fuzzy-search (not tee)

  # If fuzzy-search failed/cancelled
  if (( pstatus != 0 )); then
    echo "No dir was selected"
    return $pstatus
  fi

  # Only cd if it looks like a real directory
  if [[ -n "$result" && (-d "$result" || -f "$result") ]]; then
    $EDITOR "$result" || { echo "Failed to open: $result"; return 1; }
  else
    echo "No dir was selected"
    return 1
  fi
}

function dumb () {
	look $1 | awk '{ print length, $0 }' | sort -ns |  cut --delimiter=" " --fields=2 | fzf | tee /dev/tty | xargs wl-copy --
}

# WARN: not tested
function customkey () {
    # params: num name command keybindings
    # TODO: the num should be auto

    first_part="org.gnome.settings-daemon.plugins.media-keys.custom-keybinding"
    second_part="/org/gnome/settings-daemon/plugins/media-keys/custom-keybindings/custom"

    gsettings set "$first_past:$seconf_part$1/" "name" "$2"
    gsettings set "$first_past:$seconf_part$1/" "command" "$3"
    gsettings set "$first_past:$seconf_part$1/" "keybindings" "$4"

    all_settings=$(gsettings get org.gnome.settings-daemon.plugins.media-keys custom-keybindings)
    all_settings+=('$second_part$1')

    gsettings set org.gnome.settings-daemon.plugins.media-keys custom-keybindings "$all_settings"
}

function tapClick () {
    isTap=$(gsettings get org.gnome.desktop.peripherals.touchpad tap-to-click)
    if [ "$isTap" = true ]; then
	gsettings set org.gnome.desktop.peripherals.touchpad tap-to-click false
    else
	gsettings set org.gnome.desktop.peripherals.touchpad tap-to-click true
    fi
}

function ai () {
	str=$(echo  "$@" | tr " " "-" | xargs -I {} jq -rn --arg v {} '$v|@uri')
	curl -s "ch.at/$str"
}
